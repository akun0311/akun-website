# 哈希表——查找算法

# 哈希表

| 哈希表 | 通过一个哈希函数将N个数据映射到M个存储空间里面（默认M>N)，M是哈希表的大小，N是元素的个数。
哈希表的空间大小是被压缩了的，因此会有一定的损失。 |
| --- | --- |
|  | 哈希表的目的是**进行快速的查找, 尽可能的达到O（1）因此它的核心数据结构一定是数组**，而不是链表/树。 |
|  | 哈希表需要有**一个用于映射的散列函数，还需要有一个处理冲突的方法，另外还需要有一个。** |
|  | 哈希表的抽象数据类型是Key——index，key不一定是数字等类型，有可能是字符串 |

# 哈希函数的设计

| 一个好的哈希函数 | **完美的哈希函数，任给他一个key，他最终能够映射到一个位置。
不过，这个位置的分布是简单均匀分配在所有可能的位置里面的。**
 |
| --- | --- |
| Direct-Address table |  |
| 除数留余法 | 除数留余法就是最简单的散列函数，数组直接存储时除数留余法的一种特例。
因此可以看到除数留余法其实也是一种散列函数，
**可以说散列函数是哈希表的一个本质特征。** |
| 数字分析 | 数字分析法通常适合处理关键字位数比较多的情况，事先知道关键字的分布且关键字的若干位分布比较均匀适合。 |
| 平方取中 | 适用于不知道关键字的分布，而位数又不是很多的情况 |

# 冲突处理

| 开放寻址法——线性探测再散列 | 这个位置冲突了，我看看能不能放到这个位置的后面，一直往后面找，直到找到空位置为止。
**线性探测再散列不是一个效率特别高的方法** |
| --- | --- |
| 开放寻址法——二次探测再散列 | 二次探测再散列是为了不让关键字都聚集在某一块区域。 |
| 开放寻址法——伪随机探测再散列 |  |
| 处理冲突——再散列法 | 提前准备多个散列函数，RH就是不同的散列函数。
每当发生散列地址冲突时，就换一个散列函数计算，相信总会有一个把冲突解决掉。 |
| 处理冲突——链地址法
Closed Address | 链式哈希表的桶不存储数据元素，数据元素全部存储在链表上。 |

# 性能分析

|  | 平均查找长度 |
| --- | --- |
|  | **散列查找性能分析**
1. 散列函数是否均匀
2. 处理冲突的方法 
3. 散列表的装填因子
装填因子=$\frac{填入表中记录的个数}{散列表长度}$， 装填因子越大，产生冲突可能性越大。 |
|  |  |